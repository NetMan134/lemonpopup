#!/bin/sh
#
#	Generic script to notify and change adjustable controls
#	Only tested with volume (amixer) on OpenBSD
#	(and not by this fork maintainer)
#
#	Fork by NetMan, original by iBhagwan,
#	inspired by /r/Kwbmm's post:
#	https://blog.z3bra.org/2014/04/pop-it-up.html
#
############################################################

# For how long should the pop-up remain? (by default)
duration=3 # in seconds

# Colors (hexadecimal) - #AARRGGBB, #RRGGBB, #RGB
bar_bg='#a5000000' # Pop-up background color
bar_fg='#ffffffff' # Icon and indicators color

# Test if you're getting the right font with "fc-match"
# $ fc-match JetBrainsMonoNerdFont:style=Bold
# JetBrains Mono Bold Nerd Font Complete.ttf: "JetBrainsMono Nerd Font" "Bold"
#
# Explore the available icons using:
# $ xfd -fa JetBrainsMonoNerdFont:style=Bold
# or using "gucharmap" GUI program
icon_font="JetBrainsMonoNerdFont:style:Bold"
text_font="DejaVuSans:style:Bold"

#################################################
# This function generates a string of filled	#
# circles or a combination of full and empty	#
# circles arguments:							#
# $1 - current level (0-100)					#
# $2 - print empty squares? (default: 0)		#
#################################################
level_graph() {

    # to figure out the correct codes use
    # printf '\u2589' | od -b
	rect_fill="%{T3}\342\227\217"
	rect_empty="%{T4}\342\227\213"

	val=$1
	step=5
	count=0

	if [ $l -ne 0 ]; then
		graph=""
	else
		graph="%{T4} %{T4} "
	fi

	while [ $count -le 19 ]; do
        curr=$(echo $count*${step} | bc -l)
		if [ $curr -lt $val ]; then
			graph="${graph}${rect_fill}"
		elif [ $2 = 1 ]; then
			graph="${graph}${rect_empty}"
		fi
        count=$(echo $count+1 | bc -l)
	done
	graph="${graph}%{T1}"

	if [ -n ${3+x} ] && [ ${3} -ne 0 ]; then
		graph="%{c}${graph}%{l}"
	else
		graph="%{l}${graph}%{l}"
	fi

	echo ${graph}
}

#################################################
# cross-platform icon implementation			#
# requires: font-awesome						#
#################################################

audio_icon() {

	# muted icon?
	if [ -n ${1+x} ] && [ ${1} = "yes" ]; then
		# ico="%{T2}\uf466%{T1}"
		ico="%{T2}\357\221\246%{T1}"
		echo ${ico}
		return;
	fi

	# ramp-high volume icon is the default
	# ico="%{T2}\uf028%{T1}"
	ico="%{T2}\357\200\250%{T1}"

	# if the caller specified the current level
	# set the appropriate ramp icon
	if [ ${2} -ne -1 ]; then
		if [ ${2} -gt 30 ] && [ ${2} -le 65 ]; then
			# ico="%{T2}\uf027%{T1}"
			ico="%{T2}\357\200\247%{T1}"
		elif [ ${2} -le 30 ]; then
			# ico="%{T2}\uf026%{T1}"
			ico="%{T2}\357\200\246%{T1}"
		fi
	fi

	echo ${ico}
}

backlight_icon() {

	# ico="%{T2}\uf185%{T1}"
	ico="%{T2}\357\206\205%{T1}"
	echo ${ico}
}

brightness_icon() {
    
	# ico="%{T2}\uf185%{T1}"
	ico="%{T2}\357\206\205%{T1}"
	echo ${ico}
}

kbdlight_icon() {
	
	#if [ ${2} -eq 0 ]; then
		# 0-level icon
		# ico="%{T2}\uf40b%{T1}";
		ico="%{T2}\357\220\213%{T1}";
	#else
		# default icon
		# ico="%{T2}\uf40b%{T1}"
	#	ico="%{T2}\357\220\213%{T1}";
	#fi
	echo ${ico}
}

#################################################
# Linux pactl implementation of volume control	#
# requires: pulseaudio libpulse					#
#################################################
linux_audio_get() {
  pactl list sinks | grep -A 15 $(pactl get-default-sink) | grep 'Volume:' |\
    grep -v 'Base Volume:' | awk -F : '{print $3}' | grep -oP '.{0,3}%' |\
    sed s/.$// | tr -d ' '
}

linux_audio_status() {
    pactl list sinks | grep -A 15 $(pactl get-default-sink) | grep "^[[:space:]]Mute:" | cut -f 2 -d ':' | tr -d ' '
}

linux_audio_set() {

    local step=$2

	case "${1}" in
		toggle)
			pactl list short sinks | cut -f1 | while read -r line; do pactl set-sink-mute $line toggle; done
			break
			;;
		off)
			pactl list short sinks | cut -f1 | while read -r line; do pactl set-sink-volume $line 0%; done
			break
			;;
		max)
			pactl list short sinks | cut -f1 | while read -r line; do pactl set-sink-volume $line 100%; done
			break
			;;
		inc)
			pactl list short sinks | cut -f1 | while read -r line; do pactl set-sink-volume $line +${step}%; done
			break
			;;
		dec)
			pactl list short sinks | cut -f1 | while read -r line; do pactl set-sink-volume $line -${step}%; done
			break
			;;
		*)
			echo 1
			return 1
			;;
	esac
	echo 0
	return 0
}

#################################################
# OpenBSD implementation of volume control		#
# notes: wasn't tested yet						#
#################################################
openbsd_audio_get() {
	# local vol=$(bc -l <<< "scale=0;$(mixerctl outputs.master | sed 's/.*,//g')/2.55")
	echo $vol
}

openbsd_audio_status() {
	local muted=$(mixerctl | grep outputs.master.mute=on)
	if [ -z ${muted} ]; then echo "on";
	else echo "off"; fi
}


openbsd_audio_set() {

    local step=$2

    case "${1}" in
        toggle)
            mixerctl outputs.master.mute=toggle
            break
            ;;
        off)
            mixerctl outputs.master=0
            break
            ;;
        max)
            mixerctl outputs.master=255
            break                                                                                           
            ;;   
        inc)  
            mixerctl outputs.master=+${step}
            break
            ;;   
        dec)  
            mixerctl outputs.master=-${step}
            break
            ;;   
        *)    
            echo 1
            return 1
            ;;      
    esac      
    echo 0
    return 0
}

#################################################
# Linux implementation of backlight control		#
# requires: xorg-xbacklight						#
#################################################
linux_backlight_get() {
	local cur=$(xbacklight -get | sed 's/\..*//')
	echo $cur
}

linux_backlight_status() {
	echo "on"
}

linux_backlight_set() {

    local step=$2

    case "${1}" in
        toggle)
			# not implemented
			echo 1
			return 1
			;;
        off)
			xbacklight -set 5 -time 0
            break
            ;;
        max)
            xbacklight -set 100 -time 0
            break                                                                                           
            ;;   
        inc)  
            xbacklight -inc ${step} -time 0
            break
            ;;   
        dec)  
            xbacklight -dec ${step} -time 0
            break
            ;;   
        *)    
            echo 1
            return 1
            ;;      
    esac      
    echo 0
    return 0
}

#################################################
# Linux implementation of brightness control    #
# requires: xorg-xrandr							#
#################################################
linux_brightness_get() {
    local cur=$(xrandr --verbose | grep Brightness: | head -1 | cut -d. -f2)
    echo $cur
}

linux_brightness_status() {
    echo "on"
}

brightness_inc() {
	local step=$2
    local val=$(echo "($1 + $step)" | bc -l)
    if [ $val -gt 99 ]; then
        echo 0.99
    else
        echo $(echo "$val / 100" | bc -l)
    fi
}

brightness_dec() {
	local step=$2
    local val=$(echo "($1 - $step) / 100" | bc -l)
    echo $val
}

linux_brightness_set() {

    local step=$2

    case "${1}" in
        toggle)
            # not implemented
            echo 1
            return 1
			;;
        off)
            val=0.25
            break
            ;;
        max)
            val=0.99
            break                                                                                           
            ;;   
        inc)  
			val=$(brightness_inc $3 $2)
            break
            ;;   
        dec)  
			val=$(brightness_dec $3 $2)
            break
            ;;   
        *)    
            echo 1
            return 1
            ;;      
	esac
	if [ -n ${val} ]; then
        display=$(xrandr | grep " connected" | cut -d' ' -f1)
		xrandr --output ${display} --brightness ${val}
		redshift -o > /dev/null 2>&1
	fi
    echo 0
    return 0
}

#################################################
# Linux implementation of mac kbdlight control	#
# requires: kbdlight (from the AUR)				#
# https://github.com/WhyNotHugo/kbdlight		#
#################################################
linux_kbdlight_get() {
    local cur=$(echo $(kbdlight get)/2.55 | bc -l | awk '{print int($1+0.5)}')
    echo $cur
}

linux_kbdlight_status() {
    echo "on"
}

linux_kbdlight_set() {

    local step=$2

    case "${1}" in
        toggle)
            # not implemented
            echo 1
            return 1
            ;;
        off)
            kbdlight off
            break
            ;;
        max)
            kbdlight max
            break                                                                                           
            ;;   
        inc)  
            kbdlight up ${step}%
            break
            ;;   
        dec)  
            kbdlight down ${step}%
            break
            ;;   
        *)    
            echo 1
            return 1
            ;;      
    esac      
    echo 0
    return 0
}

#############################################################################################
# Parse the command line arguments, parsing sample code taken from here:					#
# https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash	#
#############################################################################################

usage() {
	echo "usage: lemonpopup  -p <audio|backlight|brightness|kbdlight>          \\";
	echo "                   [ -evrl ] [ -i <step> | -d <step> | -o | -m | -T ] \\";
	echo "                   [ -a <text> ] [ -t <time>]";
	echo "options:";
	echo "       -h, --help                  Show this help";
	echo "       -v, --verbose               Print verbose output";
	echo "       -i, --increase <step>       Increase current level";
	echo "       -d, --decrease <step>       Decreasse current level";
	echo "       -o, --off                   Set current level to off";
	echo "       -m, --max                   Set current level to max";
	echo "       -T, --toggle                Toggle on|off (if applicable)";
	echo "       -t, --time <seconds>        Set the popup duration";
	echo "       -e, --empty                 Print empty squares (default=false)";
	echo "       -r, --ramp                  Ramp icon based on level (default=false)";
	echo "       -l, --line                  Print as one line (disable multiline)";
	echo "       -a, --text <text>           Print additonal output text";
	echo "       -p, --provider <value>      Set the current provider";
	echo "                        audio      Set audio volume";
	echo "                    backlight      Set screen backlight";
	echo "                   brightness      Set screen brightness (xrandr)";
	echo "                     kbdlight      Set keyboard LEDs";
}

# saner programming env: these switches turn some bugs into errors
#set -o errexit -o pipefail -o noclobber -o nounset
set -o noclobber -o nounset

# -allow a command to fail with !’s side effect on errexit
# -use return value from ${PIPESTATUS[0]}, because ! hosed $?
getopt --test > /dev/null 
if [ $? -ne 4 ]; then
    echo '`getopt --test` failed in this environment.'
    exit 1
fi

OPTIONS=hvp:omTerli:d:a:t:
LONGOPTS=help,verbose,provider:,off,max,toggle,empty,ramp,line,increase:,decrease:,text:,time:

# -regarding ! and PIPESTATUS see above
# -temporarily store output to be able to check for errors
# -activate quoting/enhanced mode (e.g. by writing out “--options”)
# -pass arguments only via   -- "$@"   to separate them correctly
PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name "$0" -- "$@")
if [ $? -ne 0 ]; then
    # e.g. return value is 1
    #  then getopt has complained about wrong arguments to stdout
	usage;
    exit 2
fi
# read getopt’s output this way to handle the quoting right:
eval set -- "$PARSED"

# NULL command / text
# Don't change
NULL=NULL

#d=0 provider= cmd=$NULL v=0 e=0 r=0 l=0 s=5 outText=$NULL
d=0 provider= cmd=$NULL v=0 e=0 r=0 l=0 s=5 outText=$NULL
# now enjoy the options in order and nicely split until we see --
while true; do
	case "$1" in
		-t | --time)
			case $2 in
				''|*[!0-9]*)
					echo "error: Invalid duration:" $2 >&2;
					exit 1
					;;
				*)
					duration=$2
					;;
			esac
			shift 2
			;;
		-h | --help)
			usage;
			exit 0
			;;
		-v | --verbose)
			v=1
			shift
			;;
		-p | --provider)
			provider=$2
			shift 2
			;;
		-i | --increase)
			case $2 in
				''|*[!0-9]*)
					echo "error: Invalid step:" $2 >&2;
					exit 1
					;;
				*)
					s=$2
					cmd=inc
					;;
			esac
			shift 2
			;;
		-d | --decrease)
			case $2 in
				''|*[!0-9]*)
					echo "error: Invalid step:" $2 >&2;
					exit 1
					;;
				*)
					s=$2
					cmd=dec
					;;
			esac
			shift 2
			;;
		-o | --off)
			cmd=off
			shift
			;;
		-m | --max)
			cmd=max
			shift
			;;
		-T | --toggle)
			cmd=toggle
			shift
			;;
		-e | --empty)
			e=1
			shift
			;;
		-r | --ramp)
			r=1
			shift
			;;
		-l | --line)
			l=1
			shift
			;;
		-a | --text)
			outText="$2"
			shift 2
			;;
		--)
			shift
			break
			;;
		*)
			# Never get here!
			echo "error: error while parsing command line arguments"
			usage;
			exit 3
			;;
	esac
done

# handle non-option arguments
if [ $# -gt 0 ]; then
    echo "error: unrecgonized option"
	usage;
    exit 4
fi

# can't operate without a provider

if [ "${provider}" = "audio" ]    \
|| [ "${provider}" = "backlight" ] \
|| [ "${provider}" = "brightness" ] \
|| [ "${provider}" = "kbdlight" ]; then
    dump=1
elif [ -z ${provider} ]; then
	echo "error: provider not specified"
	usage;
	exit 4
else
	echo "error: unknown provider"
	usage;
	exit 4
fi

# verify we have the right version of lemonbar
echo "" | lemonbar -m -d 2>&1 | grep invalid
if [ $? -eq 0  ]; then
    echo "You need lemonbar multiline version to use this program properly"
    echo "Download from: https://github.com/ibhagwan/bar"
    echo "Reverting to single line"
    l=1
fi

#################################################
# Generates our popup!							#
# Arguments:                                    #
# $1 - current level (0-100)                    #
# $2 - print empty squares? (default: 0)        #
#################################################
lemonpopup() {

	# our text
	txt="${1} $(level_graph ${2} ${3} ${l})"

	# are we using multiline or single line?
	if [ $l -ne 0 ]; then
		barw=300
		barh=70
		txt_size=8
		txt_offset=-20
		ico_size=50
		ico_offset=0
		rect_size=8
		rect_offset=-20
		opt_ml=""
		if [ ! ${4} = $NULL ]; then
			txt="${txt} %{r}%{O-0}%{T1}${4}%{T1}%{r}"; fi
	else
		barw=200
		barh=200
		txt_size=8
		txt_offset=10
		ico_size=100
		ico_offset=-15
		rect_size=8
		rect_offset=10
		opt_ml="-m"
		if [ ! ${4} = $NULL ]; then
			txt="${txt} %{c}%{T1}${4}%{T1}%{l}"; fi
	fi

    bar_font_0="${text_font}:size=${txt_size}"                    # txt font
    bar_font_1="${icon_font}:pixelsize=${ico_size}:Style:Bold"    # icon font
    bar_font_2="${icon_font}:pixelsize=${rect_size}:Style:Bold"   # full rectangles
    bar_font_3="${icon_font}:pixelsize=${rect_size}:Style:Bold"   # empty rectangles

	# geometry                                       
	primary_monitor_x=$(xrandr | grep primary | tr -s ' ' ';' | cut -f 4 -d ';' | cut -f 1 -d 'x')
	primary_monitor_y=$(xrandr | grep primary | tr -s ' ' ';' | cut -f 4 -d ';' | cut -f 2 -d 'x' | cut -f 1 -d '+')
	bar_x_placement=$(xrandr | grep primary| tr -s ' ' ';' | cut -f 4 -d ';' | cut -f 2 -d '+')
	bar_y_placement=$(xrandr | grep primary| tr -s ' ' ';' | cut -f 4 -d ';' | cut -f 3 -d '+')
    barx=$(echo ${primary_monitor_x}/2-${barw}/2+${bar_x_placement} | bc -l | cut -d. -f1)
    bary=$(echo ${primary_monitor_y}/2+${barh}+${bar_y_placement} | bc -l | cut -d. -f1)

	# set bar geometry and options
	baropt="${opt_ml} -d -n lemonpopx"
	baropt="${baropt} -g ${barw}x${barh}+${barx}+${bary}"
	baropt="${baropt} -F${bar_fg} -B${bar_bg}"
	baropt="${baropt} -o ${txt_offset}  -f ${bar_font_0}"
	baropt="${baropt} -o ${ico_offset}  -f ${bar_font_1}"
	baropt="${baropt} -o ${rect_offset} -f ${bar_font_2}"
	baropt="${baropt} -o ${rect_offset} -f ${bar_font_3}"
    
    # replace % with %% for printf to work
    txt=$(echo ${txt} | sed -e 's/%/%%/g')

	# Print verbose output
	if [ $v -ne 0 ]; then
		echo "Lemonbar:"
		echo "    text:          ${txt}"
		echo "    cmd:           lemonbar ${baropt}"
	fi

	# Get rid of all previous lemonbars
	# Thanks to @Kwbmm for the below solution!
	# https://github.com/ibhagwan/lemontify/issues/1
	#
	# I tweaked it a bit by adding a name to lemonbar
	# and killing specific lemonbars with that name
	# 										  ~NetMan
	for lemonwind in $(xdotool search --name lemonpopx); do
		xdotool windowunmap $lemonwind
	done

	# And finally print everything to lemonbar!
	(printf "${txt}"; sleep ${duration}) | lemonbar ${baropt}
}

# Our platform
platform=$(uname -s | awk '{print tolower($0)}') # Either Linux or OpenBSD (lowercased)
# Demanded provider icon for current state
fnc_ico=${provider}_icon
# Current provider level
fnc_lvl=${platform}_${provider}_get
# Set provider level
fnc_set=${platform}_${provider}_set
# Current provider status (muted, off etc.)
fnc_status=${platform}_${provider}_status

retval=-1 # The hell that's for ~NetMan

# First we perform the demanded operation,
# using a platform and provider specific function
if [ -n ${cmd} ]; then
	# xrandr brightness requires current level to adjust
	if [ ${provider} = "brightness" ]; then
		lvl=$(eval ${fnc_lvl})
		retval=$(eval ${fnc_set} ${cmd} ${s} ${lvl})
	else
		retval=$(eval ${fnc_set} ${cmd} ${s})
	fi
fi

# get current level & status
lvl=$(eval ${fnc_lvl})
status=$(eval ${fnc_status})

# ramp based icons and kbdlight provider require
# current level to adjust the icon
if [ $r -ne 0 ] || [ ${provider} = "kbdlight" ]; then
	ico=$(eval  ${fnc_ico} ${status} ${lvl})
else
	ico=$(eval  ${fnc_ico} ${status} -1)
fi

# Adjust the icon to multiline or single line
if [ ${l} -ne 0 ]; then
	ico="%{l}%{O+12}$ico%{l}"
else
	ico="%{c}%{O-35}$ico%{l}"
fi

# Print verbose output
if [ $v -ne 0 ]; then
	echo "Platform:          ${platform}"
	echo "Options:"
	echo "    verbose:       on"
	echo "    duration:      ${duration} seconds"
	echo "    provider:      ${provider}"
	echo "    command:       ${cmd}"
	echo "    empty:         ${e}"
	echo "    ramp:          ${r}"
	echo "    line:          ${l}"
	echo "    step:          ${s}"
	echo "    text:          ${outText}"
	echo "Functions:"
	echo "    ${fnc_set}() = ${retval}"
	echo "    ${fnc_lvl}() = ${lvl}"
	echo "    ${fnc_status}() = ${status}"
	echo "    ${fnc_ico}() = ${ico}"
fi

if [ -z "${ico}" ] || [ -z "${lvl}" ]; then
	echo "critical error: unable to determine platform|provider icon & level"
	exit 5
fi

lemonpopup $ico $lvl $e $outText;
